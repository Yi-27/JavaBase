#  Day1		2020/6/5

+ Java仍然会存在内存泄漏和溢出的问题。

+ 文档注释，注释内容可以被JDK提供的工具javadoc所解析，被生成一套网页文件行形式对于该程序的说明文档。

    

## 八种基本数据类型

+ 数值型
    + 整数型（byte,short,int,long）1/2/4/8字节
        + 声明Long型变量，必须以"l"或"L"结尾
    + 浮点类型（float,double）
        + float，单精度，最多7位有效数字。
            + 声明时，必须以'f'或'F'结尾
            + 4字节，-3.403E38~3.403E38
            + 表示的范围比long还要大
        + double，双精度，8字节
            + 定义浮点型变量时，通常使用double。
+ 字符型（char）
    + 一字符，2字节
    + 声明时使用单引号，'a'
    + 转义字符算一个字符
    + 直接使用Unicode值来表示字符型常量，‘\u0043'，C
+ 布尔型（boolean）
+ 四种引用数据类型
    + 类（class）
    + 接口（interface）
    + 数据（[]）



# Day2		2020/6/6

七种基本数据类型变量间的运算，不包含boolean类型

## 自动类型提升

+ 范围小的和范围大做运算时，结果自动提升为容量大的数据类型。

+ ```java
    byte b1 = 2;
    int i1 = 129;
    
    byte b2 = b1 + i1; // 编译不通过
    int i2 = b1 + i1; 
    long l1 = b1 + i1;
    float f = b1 + i1; // 这些都可以编译通过
    
    short s1 = 213;
    double d2 = s1; // 直接这样赋值也行
    ```

+ ```java
    char c1 = 'a';
    int i3 = 10;
    int i4 = c1 + i3; // 编译通过
    
    short s2 = 10;
    char c2 = c1 + s2; // 编译不通过，至少也得是int型
    
    byte b2 = 10;
    char c3 = c1 + b2; // 编译也不行
    
    char c = ''; // 编译不通过
    
    short s3 = b2 + s2; // 也不行
    ```

+ 特别的，**当byte、short、char做运算时，结果为int型**

    + 甚至是byte + byte，short + short也一样
    + 只是因为很容易运算的时候就超过范围了

## 强制类型转换

+ 自动提升运算的逆运算

+ ```java
    double d1 = 12.6;
    int i1 = (int)d1; // 12 截断操作，可能会损失精度
    
    long l1 = 123;
    short s2 = (short)l1;
    
    int i2 = 128;
    byte b1 = (byte)i2; // -128 精度损失了 变为负的是二进制的问题
    ```

+ 数值类型编码情况

    + ```java
        long l = 123213; // 不加 l或L 也能编译过 这里会被当成int
        // 但是如果数特别大还是会编译失败
        ```

    + 对于整形常量，默认类型为int型

    + 浮点型常量，默认类型为double型

+ 字符串类型String

    + 引用数据类型
    + 可以和8种基本数据类型变量做运算，只能是连接运算 +
    + 运算结果仍是String类型
    + String 强转成其他基本类型是不能直接像 (int) 这样的，需要用到特定的方法，比如Integer.parseInt("123")

+ 练习

    + ```java
        char c = 'a'; // a97 A65
        int num = 10;
        String str = "hello";
        c + num + str; // 107hello
        c + str + num; // ahello10
        c + (num + str); // a10hello
        ```


## 进制

+ 二进制，**0b**或**0B**开头
    + 正数，原码、补码、反码都一样
    + 负数，原码除符号位外各个位取反得到反码，反码+1为补码
    + 计算机的底层都以补码的方式来存储数据
+ 八进制，**0**开头
+ 十六进制，**0x**或**0X**开头
+ 打印出来都是十进制表示
+ 十进制转二进制
    + 除 2 取 余的逆



# Day3		2020/6/7

+ %，取余运算，结果的符号与被模数的符号相同

+ 自增自减1，都不会改变本身变量的数据类型。比如，short型的变量++后仍是short型，byte型变量也是改变本身的数据类型

    + +=，这样的赋值运算符也不会改变本身

+ 支持连续赋值，a=b=10;，但不能int a=b=10;

+ 比较运算符，instanceof，检查是否是类的对象，比如"hello" instanceof String，返回true 


## 逻辑运算符

+ &，逻辑与，符号左右都会执行
+ &&，短路与，符号右边不执行了
+ |，逻辑或
+ ||，短路或
+ !，逻辑非
+ ^，逻辑异或

+ 位运算符

    + 优先级与字符串的连接符+相同

    + `<<`，左移，在一定范围内，每向左移一位，相当于 * 2

    + `>>`，右移，原最高位为1就补1，其他空缺位补0

    + `>>>`，无符号右移

    + &，与运算

    + |，或运算

    + ^，异或运算

        + ```java
            int a = 10,b=5;
            // 交换两个值
            a = a ^ b;
            b = a ^ b;
            a = a ^ b;
            // a = 5 b = 10
            ```

        + 

    + ~，取反运算，~6=-7

+ 运算符的优先级

    + 只有单目运算符、三元运算符和赋值运算符是从右向左运算的。


## 从键盘获取输入值

+ ```java
    import java.util.Scanner;
    Scanner scan = new Scanner(System.in);
    int num = scan.nextInt(); // 从控制台获取输入的int数值
    ```

+ Scanner没有提供相关的方法来获取char型数据，只能获取一个字符串

+ 字符串的charAt(index)方法获取指定位置上的字符

+ 有多种next()方法来获取输入

## 随机数

+ Math.random(); // [0.0, 1.0)
+ 公式：(int)(Math.random() * (b - a + 1) + a); [a,b)

+ switch结构中的表达式，只能是byte、short、char、int、枚举类型、String类型

    + default的位置是灵活的，上中下都行
    + 能用if-else又能用switch-case的情况下，优先选switch-case，因为其执行效率稍高

+ system.currentTimeMillis(); // 获取19700101000000距离到现在的毫=秒数，long型


## 嵌套循环，带标签的break和continue

+ ```java
    for(int i=1; i<=4; i++){
        for(int j=1l i<=10; j++)
            if(j%4 == 0){
                break; // 默认结束最近的一层循环
                continue; // 默认跳出最近的一层循环
            }
    }
    ```

+ ```java
    label:for(int i=1; i<=4; i++){
        for(int j=1l i<=10; j++)
            if(j%4 == 0){
                break label; // 结束指定标签的循环
                continue label; // 跳出指定标签的当次循环
            }
    }
    ```

    
    

# Day4		2020/6/8

## **数组**，属于引用数据类型的变量

+ 长度确定后就不能修改

+ 数组的声明和初始化

    + ```java
        int[] ids; // 声明
        // 静态初始化  数组的初始化和数组元素的赋值操作同时进行
        ids = new int[]{101,102,103,104};
        // 动态初始化  分开进行
        ids = new int[4];
        
        int[] arr = {1,2,3}; // 可以直接  类型推断
        // 但是不能ids = {1,2,3};
        ```

+ 数组元素的默认初始化值

    + 整形为 0
    + 浮点型为 0.0
    + char型为 0或‘\u0000’，而非'0'
    + boolean型为 false
    + String型为 null，不是"null"，引用类型都是null

+ 数组在内存中的解析（一维数组）

    + ```java
        int[] arr = new int[]{1,2,3};
        String[] arr1 = new String[4];
        arr1[1] = "刘德华";
        arr1[2] = "张学友";
        arr1 = new String[3];
        ```

    + 首先**栈空间**内，创建arr

    + 再在**堆空间**内，创建3个连续的int型空间作为arr数组的内存空间，并把首地址值（十六进制）给栈空间的arr

    + 通过栈空间的arr的值就能找到堆空间其对应的值了

    + 再把1,2,3赋值到每个内存空间中

    + String型数组一样，先在栈空间，创建arr1

    + 再在堆空间开辟一个4个空间，并把首地址值赋给arr1

    + 再根据arr1首地址赋值到具体的空间内

    + **再new了就又在堆空间内开辟新的空间**，把新的首地址赋值给arr1

    + 根据引用计数算法，判断堆空间的值是否还有栈空间的引用，没有的话，会在之后的某个不确定的时间，通过垃圾回收机制把空间给释放掉

    + ![image-20200608162538368](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200608162538368.png)

    + **注：**这里String类型其实并不是放在堆空间内的，而是放在**字符串常量池**内的。

## 多维数组

+ 从数组底层的运行机制来看，其实没有多维数组

+ 二维数组的声明和初始化

    + ```java
        // 静态初始化
        int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}}; // int[] arr[] 或 int arr[][] 都可以
        // 动态初始化
        String[][] arr2 = new String[3][2];
        String[][] arr3 = new String[3][];
        
        arr1; // 地址 [[I@6d06d69c  [[表示两维数组 I表示int型
        arr1[0]; // 地址 [I@15db9742
        arr1[0][0]; // 0 
        
        arr2[0]; // 地址 [Ljava.lang.String;@7852e922
        arr2[0][0]; // null
        
        arr3[0]; // null
        arr3[0][0]; // 空指针异常
        
        
        // 可以直接 int[][] arr = {{1,2,3},{4,5},{6,7,8}};
        
        arr1.length; // 3
        arr1[1].length; // 2
        
        ```

    + ![image-20200608163935139](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200608163935139.png)

        + 二维数组的内存解析
            + ![image-20200608172054918](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200608172054918.png)
    
+ 数组中，arr2 = arr1; 只是把arr1的地址赋值给arr2，动arr2的值，就是动arr1的值。

    + 有一定前提，arr2和arr1的类型要匹配，匹配后，两个都指向堆空间的唯一的一个数组实体
    + 比如，arr2是二维数组的地址，arr1是一维数组的地址，就不能这样赋值了
    + **arr2 = arr1;不能称作数组的复制**

## **内存的简化结构**

+ 内存规划在JVM中
+ 栈，stack
    + 局部变量，放在方法中的变量都是局部变量
+ 堆，heap
    + new 出来的结构，对象，数组
+ 方法区
    + 常量池
    + 静态域
    + 类加载的一些信息

## **数据结构与算法**

+ 数据与数据之间的逻辑关系：集合、一对一、一对多、多对多
+ 数据的存储结构
    + 线性表（一对一）：顺序表（比如，数组）、链表、栈（先进后出）、队列（先进先出）
    + 树形结构（一对多）：二叉树
    + 图形结构（多对多）：无向图、有向图 

+ 基础算法：
  
    + 排序算法
    + 搜索算法
    
+ 数组中涉及的常见算法

    + 赋值型
        + 创建一个长度为6的int型数组，要求数组的值都在1-30内，且是随机赋值。同时要求各元素的值各不相同
        + 回形数
    + 数值型
        + 求最大值、最小值、平均值、总和
    + 复制
        + new 新的堆空间后，再for循环复制进去
    + 反转
        + 中间变量，首尾交换
        + new新数组后倒着复制进去，然后旧数组指向新数组



# Day5		2020/6/9

## 数组查找算法

+ 线性查找，就是循环一个一个的找

+ 二分查找

    + 比较快

    + 前提要先有序

    + ```java
        int[] arr = new int[]{1,2,3,4,5,6};
        int dest = 2;
        int head = 0; // 初始的首索引
        int end = arr.length - 1; // 初始的末索引
        boolean isFlag = true;
        
        while(head <= end){
            int middle = (head + end) / 2;
            if(dest == arr[middle]){
                System.out.println("找到了指定的元素，位置为：" + middle);
                isFlag = false; // 说明找到了
                break;
            }else if(arr[middle] > dest){
                end = middle -1;
            }else{
                head = middle + 1;
            }
        }
        
        if (ifFlag == false){
            System.out.println("未找到！")
        }
        
        ```

## 排序算法

+ 选择排序

    + 直接选择排序
    + 堆排序

+ 交换排序

    + 冒泡排序

        + ```java
            // 冒泡排序
            int[] a = new int[]{1,9,5,7,6,3,4,8,0,5,2,0,2};

          for(int i=0; i<a.length-1; i++) {
              for(int j=0; j<a.length-1-i; j++) {
                  if(a[j] > a[j+1]) {
                      // 交换值
                      int temp = a[j];
                      a[j] = a[j+1];
                      a[j+1] = temp;
                  }
              }
              List<Integer> iList = Arrays.stream(a)
                  .boxed()
                  .collect(Collectors.toList());
              System.out.println(iList);
          }
          List<Integer> iList = Arrays.stream(a)
              .boxed()
              .collect(Collectors.toList());
          System.out.println(iList);
          ```
          
        + ```
            [1, 5, 7, 6, 3, 4, 8, 0, 5, 2, 0, 2, 9]
            [1, 5, 6, 3, 4, 7, 0, 5, 2, 0, 2, 8, 9]
            [1, 5, 3, 4, 6, 0, 5, 2, 0, 2, 7, 8, 9]
            [1, 3, 4, 5, 0, 5, 2, 0, 2, 6, 7, 8, 9]
            [1, 3, 4, 0, 5, 2, 0, 2, 5, 6, 7, 8, 9]
            [1, 3, 0, 4, 2, 0, 2, 5, 5, 6, 7, 8, 9]
            [1, 0, 3, 2, 0, 2, 4, 5, 5, 6, 7, 8, 9]
            [0, 1, 2, 0, 2, 3, 4, 5, 5, 6, 7, 8, 9]
            [0, 1, 0, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9]
            [0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9]
            [0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9]
            [0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9]
            [0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9]
            ```

        + 

    + 快速排序

        + 

+ 插入排序

    + 直接插入排序
    + 折半插入排序
    + Shell排序

+ 归并排序

+ 桶式排序

+ 基数排序

    

## 算法的五大特征

+ 输入
+ 输出
+ 有穷性
+ 确定性
+ 可行性



## Arrays工具类

+ java.util.Arrays类
    + boolean equals(int[] a, int[] b)，判断两个数组是否相等
    + void fill(int[] a, int val)，将指定值填充到数组之中
    + void sort(int[] a)，对数组进行排序
    + int binarySearch(int[] a, int key)，对排序后的数组进行二分法检索指定的值



## 数组中的常见异常

+ 数组角标越界异常（就是不在数组length内）

    + **ArrayIndexOutOfBoundsExcetion**

+ 空指针异常

    + **NullPointerException**

    + 情况一

        + ```java
            int[] arr1 = new int[]{123};
            arr1 = null;
            arr1[0]; // 空指针异常
            ```

    + 情况二

        + ```java
            int[][] arr2 = new int[4][];
            arr2[0]; // null
            arr2[0][0]; // 空指针异常
            ```

    + 情况三

        + ```java
            String[] arr3 = new String[]{"AA", "BB", "CC"};
            arr3[0] = null;
            arr3[0]; // null
            arr3[0].toString(); // 空指针异常
            ```

        + 



# Day6		2020/6/10

## 面向对象

+ Java类及类的成员
    + 属性
    + 方法
    + 构造器
    + 代码块
    + 内部类
+ 面向对象三个特征
    + 封装性
    + 继承性
    + 多态性
+ 其它关键字
    + this
    + super
    + static
    + final
    + abstract
    + interface
    + package
    + import



## 对象的创建和使用：内存解析

![image-20200610172916326](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200610172916326.png)

**运行时数据区**

+ 方法区
    + 存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据
+ 堆
    + 存放对象实例以及数组
+ 虚拟机栈（通常意义上指的栈）
    + 主要用于**存储局部变量**等，方法中的变量都是局部变量
        + **但类属性是存放在堆空间中的**
    + 基本数据类型
    + 对象引用（reference类型，是对象在堆内存放的首地址）
    + 方法执行完，自动释放
+ 本地方法栈
    + 通过Java调用本地C或C++的接口
+ 程序计数器

![image-20200610174706375](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200610174706375.png)



引用类型的变量，只能存储两类值

+ null
+ 地址值（含变量的类型）



## 类中成员变量和局部变量的异同点

**相同点：**

+ 定义的方式
+ 先声明，后使用
+ 都有其对应的作用域

**不同点：**

+ 在类中声明的位置不同
+ 权限修饰符不同
    + 声明属性时，指明权限
        + 常用的权限
            + private，私有
            + public，公共
            + protected，保护
            + 缺省
+ 默认初始化值
    + 属性：根据其类型，都有默认初始化值
        + 整形，0
        + 浮点型，0.0
        + 字符型，0或'\u0000'
        + 布尔型，false
        + 引用数据类型（类，数组，接口等），null
    + 局部变量：无默认初始化值
        + 一定要显示赋值
        + 形参在调用时才被赋值
    + 在内存中加载的位置不同
        + 属性，加载到堆空间中（非static）
        + 局部变量，加载到栈空间 



## 方法的声明

+ 权限修饰符

    + private
    + public
    + protected
    + 可省

+ 关键字（可省）

+ 返回值类型

    + 有返回值
        + 指定返回值类型
        + 用return关键字返回指定类型的变量或常量
    + 无返回值（void）
        + 通常不用return
        + 但是如果使用的话，只能`return;`，用于提前结束方法

+ 方法名

    + 属于标识符，遵循其规则和规范，见名知意

+ 形参列表

    + 不能默认值

+ 方法体

    + 内部不能再定义方法

    

## 方法的重载

形参的个数和类型不相同即可。

跟方法返回类型无关。



## 匿名对象的使用

直接 new Human();

使用时，直接 new Human().eat(); 

匿名对象只能调用一次

使用的情况

+ ![image-20200610192236702](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200610192236702.png)



# Day7 2020/6/20

## 方法的重载

+ 可变个数形参（Varargs,variable number of arguments）机制
    + 允许直接定义能和多个实参相匹配的形参
    + 格式：数据类型 ... 变量名，例如String ... strs
    + 其实就是个数组，但是如何有同样数据类型的重载方法，但是调用时只给一个参数时，优先调用单个参数的重载方法，而不是调用可变个数形参的方法
    + 而且，不能再这样重载String[] strs，这个同上面其实本质是一致的
    + 可以test.show("123", "456", "789");这样使用，也可以test.show({"123", "456", "789"});这样传一个数组
    + 在方法中，必须声明在末尾，同时只能声明一个



## 变量的赋值

基本类型变量赋值，就是栈空间中直接赋值。

+ 而当变量赋值给另一个变量时，就是重新赋值，比如int a = 10; int b = a;



引用类型变量赋值，就是栈空间中保存堆空间数据的地址值

+ 而当变量赋值给另一个变量时，只是两个栈空间的变量引用同一个堆空间的地址值而已。
+ 因此，改变其中一个变量具体的值，另一个变量也会相应改变



## 值传递机制

如果参数是基本数据类型，实参赋给形参的就是真实的具体值

而引用数据类型，传的是地址



## 输出数组

+ ```java
    int[] arr = new int[]{1,2,3};
    arr; // 地址值
    
    char[] arr1 = new char[]{'a', 'b', 'c'};
    arr1; // abc
    ```

+ 这是因为调用了System.out.println();中 println的重载方法



## 递归（recursion）方法

结合算法才更好理解。

+ 快排
+ 汉罗塔
+ 斐波那契数列

一个方法体内调用它自身。

方法递归包含了一种隐式循环，必须向已知方向递归，否则容易死循环。



## String的用法

虽然可以直接String str = "hello";但是它是引用数据类型，在栈空间存的还是地址。

但是这里，"hello"存在字符串常量池中，底层就是用char[]来存储的

当方法实参把字符串传给形参时，只是把常量池中的地址赋给形参了而已

当在方法中修改了形参的值，并不会影响到实参的值，而是在常量池中新建了新的值，把新的值的地址赋给形参



## 面向对象特征之：封装和隐藏

私有属性，就不能外部直接修改属性，只能通过set方法或构造方法来设置值

当我们需要给属性加以制约条件时，这个无法在属性声明时体现出来，只能通过方法进行限制条件的添加。同时将属性的权限设为私有

**封装性的体现**：

+ 将类的属性私有化，同时提供公共的方法来获取（getXXX）和设置（setXXX）此属性的值

+ 不对外暴露的私有的方法
+ 单例模式
+ 如果不希望类在包外被调用，可以将类设置为缺省

封装性的体现，需要权限修饰符来配合

+ private
+ 缺省
+ protected
+ public

4种权限都可以修饰类的内部结构：属性、方法、构造器、内部类

修饰类的话只能是public和缺省



封装性：Java提供了4中权限修饰符来修饰类及类的内部结构，体现类及类的的内部结构在被调用时的可见性的大小。



## 构造器

当显式定义了类的构造器后，系统将不再提供默认的无参构造器



## 属性赋值的先后顺序

+ 默认初始化
    + 不同数据类型值不同，比如int型的默认初始化值为0
+ 显式初始化
+ 构造器中赋值
+ 通过 对象.方法 或 对象.属性 的方式赋值



## JavaBean

JavaBean是一种Java语言写成的可重用组件。

**标准**：

+ 类是公共的
+ 有一个无参的公共的构造器
+ 有属性，且有对应的set/get方法



## this关键字

this可以修饰：属性、方法、构造器

类内也可以 this.方法 调用类中的方法

构造器中也可以用this.调用正在创建的类的对象和属性

**可以在重载的构造方法中，通过this()调用无参构造方法，也可以this(参数);调用有参的构造函数**

但只能有一个，构造方法中不能存在两个this();

类中还可以直接把 this 当作实参传递另一个对象的方法



## package关键字

为了更好实现项目中类的管理，提供包的概念

声明在源文件的首行，前面有空行也算首行

包名一般都小写

每 “.” 一次就代表一层文件目录

同一包下，不能命名同名的接口、类。不同包下可以



**JDK中主要的包介绍**：

![image-20200620230952469](C:\Users\Jarvis\AppData\Roaming\Typora\typora-user-images\image-20200620230952469.png)





# Day8 2020/6/21

## MVC设计模型

**视图模型层：**

+ view.utils，相关工具类
+ view.ui，自定义view

**数据模型层：**

+ model.bean/domain，数据对象封装
+ model.dao，数据库操作类
+ model.db，数据库

**控制器层：**

+ controller.activity，应用界面相关
+ controller.fragment，存放fragment
+ controller.adapter，显示列表的适配器

+ controller.service，服务相关的
+ controller.base，抽取的基类



## import关键字

导入指定包下的类、接口

声明在包的声明下面

可以通过XXX.*的方式，导入XXX包下的所有结构

如果使用的类是本包下的，可以省略import

同名包要在使用处写全包名，全类名的方式显示

子包的类也需要导入 

import static导入指定类或接口中的静态**结构**，不是具体的类或结构

+ import static java.lang.System.*;
+ 这样就可以直接 out.println();了
+ 这里的out是个静态变量

```java
String infoString = Arrays.toString(new int[]{1,2,3});
System.out.println(infoString);
// 快速打印数组
```



## 面向对象特征之继承性

好处：

+ 减少了代码的冗余，提高了代码的复用性
+ 便于功能的扩展
+ 为多态性的使用，提供了前提



**私有属性和方法也会被继承，但是不能直接在子类里通过 this.属性 来设置值，只能通过对应的set方法，同样get也是。**

**每个类会隐式继承Object类，**在java.lang包下



# Day9 2020/6/23

## 方法的重写

**override / overwrite**:

+ 重写父类的同名方法，方法名和形参列表要相同
+ 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
    + 特殊情况：子类不能重写父类中声明为private权限的方法
+ 返回值类型
    + 父类是void，子类也必须是void
    + 子类重写的方法的返回值类型也可以是父类的返回值类型的子类
        + 比如，父类的返回值类型是Object，子类就可以是String，自定义的类等等
        + 但是返回值是基本数据类型，重写的方法的返回值类型也必须是基本数据类型
+ 抛出异常的类型
    + 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型



子父类同名方法都声明为static的，这不叫重写。

static方法是不能被重写的



## 关键字super

super可以用来调用：属性、方法、构造器



**在继承中，属性时不会覆盖的**

当子父类有同名属性时，可以通过 super.属性 显示调用父类的属性

同样，super.方法 可以调用父类的方法，在子类中同名也可以这样调用

当直接父类没有想调用的属性或方法时，会往上找间接父类

在子类构造器中可以通过 super(形参列表); 的方式调用父类的构造器，也必须放在首行

**在类的构造器中，this(形参列表); 或 super(形参列表); 只能二选一，不能同时出现**

子类默认会调用 super(空);



## 子类对象实例化的过程

从结果上看：

+ 子类继承父类，会获取父类中声明的属性和方法
+ 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性

从过程上来看：

+ 无论怎么凋构造器，最终都会凋到Object()的构造器才截止
+ 所以在内存中才能看到父类中的结构，子类对象才可以进行调用

虽然创建子类对象时，调用了父类的构造器，但是自始至终只创建了一个对象，即为new 的子对象



## 多态性（Polymorphism）

理解多态性：可以理解为一个**事物的多种形态**

对象的多态性：**父类的引用指向子类的对象**（或子类的对象赋给父类的引用）

多态的使用：

+ 当调用子父类同名参数的方法时，实际执行的是子类重写父类的的方法（虚拟方法调用）

+ 有了对象的多态以后，在编译期，只能调用父类中声明的方法，但是在运行期，实际执行的是子类重写父类的方法
+ **编译，看左边；运行，看右边**

多态性的使用前提：

+ 类的继承关系
+ 方法的重写

比如说equals(Object o);就是应用到了多态

对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

**多态性是运行时行为**，编译时是看不出来是不是多态的



+ 方法重载定义的细节
    + 重载是指允许存在多个同名方法，而这些方法的参数不同
    + 同时，重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法

+ 编译和运行的角度
    + 编译器根据方法不同的参数表，对同名方法的名称做修饰。这样对于编译器而言，这些同名方法就成了是不同的方法
    + 它们的调用地址在编译期就绑定了，即在方法调用前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”
    + 对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”
    + 因此，重写是多态，重载不是多态



**注：**

+ 在多态的时候，父类引用指向子类的对象时，不能调用子类特有的方法，因为在编译的时候找不到该方法
    

## instanceof关键字

Person p = new Man(); // Man继承了Person类

​	有了对象的多态性后，内存中实际上加载了子类的属性和方法，但是由于变量声明为父类类型，导致在编译时，只能调用用父类中声明的属性和方法。

​	子类特有的属性和方法不能调用。

​	那么如何调用子类特有的属性和方法？

+ Man m = (Man)p; // 强制类型转换，这样编译器就能识别了。即向下转型
    + 注：较高级的基本数据类型（double）转换成较低级的基本数据类型（int）时，要强制类型转换才行，但是反过来则会提升。
+ 子类赋给父类声明的变量，向上转型，多态。反之向下转型

+ **强制类型转换的时候有可能会出现异常**，编译不报错，但是运行时会报错
    + 为了避免这个问题，就要用到 instanceof 关键字



使用：

+ a instanceof A ，判断对象a是否是类型A的实例。是返回true，不是返回false
+ 为了避免在向下转型时出现ClassCastException的异常，在向下转型之前，先进行instanceof的判断
+ a instanceof A的直接父类或间接父类，都会返回true



​	若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。

+ 这时只能通过super关键字来调用父类的同名方法



​	对于实例变量不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例依然不可能覆盖父类中定义的实例变量。（比如属性）